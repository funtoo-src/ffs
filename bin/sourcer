#!/usr/bin/python3
import argparse
import os
import sys

from yaml import safe_load

CLI_CONFIG = {
	"action": {"positional": True},
	"sources": {"positional": True, "nargs": "?"}
}


def parse_args():
	ap = argparse.ArgumentParser()
	for arg, kwargs in CLI_CONFIG.items():
		if "positional" in kwargs and kwargs["positional"]:
			new_kwargs = kwargs.copy()
			del new_kwargs["positional"]
			ap.add_argument(arg, **new_kwargs)
		else:
			ap.add_argument("--" + arg, **kwargs)
	return ap.parse_args()


class Sourcer:
	"""
	This class is responsible for parsing sources.yaml and performing various actions, such as downloading all source code
	or accessing metadata for a particular set of sources.
	"""

	sources = {}

	def __init__(self, infile):
		with open(infile, "r") as myf:
			for top_name, src_cats in safe_load(myf.read()).items():
				for cat_name, cat_contents in src_cats.items():
					if "defaults" in cat_contents:
						defaults = cat_contents["defaults"].copy()
					else:
						defaults = {}
					for pkg_block in cat_contents["packages"]:
						if len(pkg_block.keys()) != 1:
							raise ValueError(f"Unexpected YAML: {pkg_block}")
						name = list(pkg_block.keys())[0]
						innards = list(pkg_block.values())[0]
						if isinstance(innards, str):
							# pkgname: '1.2.3' short format:
							local_pkginfo = {"version": innards}
						elif isinstance(innards, float):
							local_pkginfo = {"version": str(innards)}
						else:
							local_pkginfo = innards
						pkginfo = defaults.copy()
						pkginfo.update(local_pkginfo)
						pkginfo["name"] = name
						pkginfo["sources"] = []
						if "url" in pkginfo and isinstance(pkginfo["url"], str):
							sources = [pkginfo["url"]]
							del pkginfo["url"]
						elif "urls" in pkginfo and isinstance("urls", list):
							sources = pkginfo["urls"]
							del pkginfo["urls"]
						else:
							raise ValueError(f"Expecting string ('url') or list of strings ('urls'): {pkginfo['url']}")
						sources_kwargs = {}
						for kwarg in [ "ext" ]:
							if kwarg in pkginfo:
								sources_kwargs[kwarg] = pkginfo[kwarg]
						for url in sources:
							pkginfo["sources"].append(url.format(version=pkginfo["version"], name=name, **sources_kwargs))
						self.sources[name] = pkginfo

	def fetch(self):
		os.makedirs("../sources", exist_ok=True)
		for key, val in sourcer.sources.items():
			print(f"Fetching {key}")
			for url in val["sources"]:
				outfile = os.path.basename(url)
				if not os.path.exists(f"sources/{outfile}"):
					result = os.system(f"( cd sources && wget -nc {url})")
					if result != 0:
						sys.exit(0)

	def unpack(self, sources):
		os.makedirs(os.path.join(os.environ["CLFS"], "build"), exist_ok=True)
		first_source = None
		for source in sources:
			if first_source is None:
				first_source = self.sources[source]
			for url in self.sources[source]["sources"]:
				tarball = url.split("/")[-1]
				print(f"cd ${{CLFS}}/build && tar xf ${{CLFS}}/sources/{tarball}")
				print(f"export {source.upper()}_VERSION=\"{self.sources[source]['version']}\"")
				print(f"cd ${{CLFS}}/build/{first_source['name']}-{first_source['version']}")


if __name__ == "__main__":
	if "CLFS" not in os.environ:
		raise EnvironmentError("Please set CLFS environment variable.")
	sourcer = Sourcer(os.path.join(os.environ["CLFS"], "sources.yaml"))
	args = parse_args()
	if args.action == "unpack":
		sources = args.sources.split(",")
		sourcer.unpack(sources)
	elif args.action == "fetch":
		sourcer.fetch()


# vim: ts=4 sw=4 noet
