--- a/lib/portage/dbapi/bintree.py	2022-01-23 21:53:04.280217745 -0300
+++ b/lib/portage/dbapi/bintree.py	2022-01-24 08:34:38.876101322 -0300
@@ -551,11 +551,10 @@
         origcp = mylist[1]
         newcp = mylist[2]
         # sanity check
-        for atom in (origcp, newcp):
-            if not isjustname(atom):
-                raise InvalidPackageName(str(atom))
+        if not isjustname(newcp):
+            raise InvalidPackageName(str(newcp))
         mynewcat = catsplit(newcp)[0]
-        origmatches = self.dbapi.cp_list(origcp)
+        origmatches = self.dbapi.match(origcp)
         moves = 0
         if not origmatches:
             return moves
--- a/lib/portage/dbapi/vartree.py	2022-01-24 08:54:09.101500179 -0300
+++ b/lib/portage/dbapi/vartree.py	2022-01-24 09:03:33.738166326 -0300
@@ -406,51 +406,51 @@
                 return True
         return False
 
-    def move_ent(self, mylist, repo_match=None):
-        origcp = mylist[1]
-        newcp = mylist[2]
-
-        # sanity check
-        for atom in (origcp, newcp):
-            if not isjustname(atom):
-                raise InvalidPackageName(str(atom))
-        origmatches = self.match(origcp, use_cache=0)
+    def move_ent(self, to_from_list, repo_match=None):
+        orig_match = to_from_list[1]
+        new_cp = to_from_list[2]
+
+        # sanity check - destination must be a catpkg
+        if not isjustname(new_cp):
+            raise InvalidPackageName(str(new_cp))
+        matches = self.match(orig_match, use_cache=0)
         moves = 0
-        if not origmatches:
+        if not matches:
             return moves
-        for mycpv in origmatches:
-            mycpv_cp = mycpv.cp
-            if mycpv_cp != origcp:
+        for found_cpv in matches:
+            mycpv_cp = found_cpv.cp
+            if mycpv_cp != orig_match:
                 # Ignore PROVIDE virtual match.
                 continue
-            if repo_match is not None and not repo_match(mycpv.repo):
+            if repo_match is not None and not repo_match(found_cpv.repo):
                 continue
 
             # Use isvalidatom() to check if this move is valid for the
             # EAPI (characters allowed in package names may vary).
-            if not isvalidatom(newcp, eapi=mycpv.eapi):
+            if not isvalidatom(new_cp, eapi=found_cpv.eapi):
                 continue
 
-            mynewcpv = mycpv.replace(mycpv_cp, str(newcp), 1)
-            mynewcat = catsplit(newcp)[0]
-            origpath = self.getpath(mycpv)
+            # Perform string replacement, replace old catpkg with new:
+            renamed_cpv = found_cpv.replace(mycpv_cp, str(new_cp), 1)
+            renamed_cat = catsplit(new_cp)[0]
+            origpath = self.getpath(found_cpv)
             if not os.path.exists(origpath):
                 continue
             moves += 1
-            if not os.path.exists(self.getpath(mynewcat)):
+            if not os.path.exists(self.getpath(renamed_cat)):
                 # create the directory
-                ensure_dirs(self.getpath(mynewcat))
-            newpath = self.getpath(mynewcpv)
+                ensure_dirs(self.getpath(renamed_cat))
+            newpath = self.getpath(renamed_cpv)
             if os.path.exists(newpath):
                 # dest already exists; keep this puppy where it is.
                 continue
             _movefile(origpath, newpath, mysettings=self.settings)
-            self._clear_pkg_cache(self._dblink(mycpv))
-            self._clear_pkg_cache(self._dblink(mynewcpv))
+            self._clear_pkg_cache(self._dblink(found_cpv))
+            self._clear_pkg_cache(self._dblink(renamed_cpv))
 
             # We need to rename the ebuild now.
-            old_pf = catsplit(mycpv)[1]
-            new_pf = catsplit(mynewcpv)[1]
+            old_pf = catsplit(found_cpv)[1]
+            new_pf = catsplit(renamed_cpv)[1]
             if new_pf != old_pf:
                 try:
                     os.rename(
@@ -462,7 +462,7 @@
                         raise
                     del e
             write_atomic(os.path.join(newpath, "PF"), new_pf + "\n")
-            write_atomic(os.path.join(newpath, "CATEGORY"), mynewcat + "\n")
+            write_atomic(os.path.join(newpath, "CATEGORY"), renamed_cat + "\n")
 
         return moves
 
--- a/lib/portage/update.py	2022-01-24 09:05:39.562314101 -0300
+++ b/lib/portage/update.py	2022-01-24 09:21:18.135409668 -0300
@@ -26,6 +26,7 @@
 from portage.eapi import _get_eapi_attrs
 from portage.exception import DirectoryNotFound, InvalidAtom, PortageException
 from portage.localization import _
+from portage.versions import cpv_getkey
 
 
 ignored_dbentries = ("CONTENTS", "environment.bz2")
@@ -41,6 +41,12 @@
         old_value = str(update_cmd[1])
         new_value = str(update_cmd[2])
 
+        if cpv_getkey(old_value) != old_value:
+            # original matched (source) package is a version range. And when handling version ranges, we don't
+            # assume that we want to perform any *DEPEND updates at all, since we aren't simply renaming a single
+            # package but splitting a single package into two packages.
+            return mycontent
+
         # Use isvalidatom() to check if this move is valid for the
         # EAPI (characters allowed in package names may vary).
         if old_value in mycontent and isvalidatom(new_value, eapi=eapi):
@@ -232,18 +238,24 @@
                 errors.append(_("ERROR: Update command invalid '%s'") % myline)
                 continue
             valid = True
+            reason = ""
             for i in (1, 2):
                 try:
                     atom = Atom(mysplit[i])
                 except InvalidAtom:
                     atom = None
+                    reason = " : '%s' is invalid." % mysplit[i]
                 else:
-                    if atom.blocker or atom != atom.cp:
+                    if atom.blocker:
+                        atom = None
+                        reason = " : Operand can't be blocker"
+                    elif i == 2 and atom != atom.cp:
+                        reason = " : Second operand (dest) must be catpkg (no version.)"
                         atom = None
                 if atom is not None:
                     mysplit[i] = atom
                 else:
-                    errors.append(_("ERROR: Malformed update entry '%s'") % myline)
+                    errors.append(_("ERROR: Malformed update entry '%s'" + reason) % myline)
                     valid = False
                     break
             if not valid:
