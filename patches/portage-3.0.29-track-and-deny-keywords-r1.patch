--- a/lib/portage/const.py	2022-01-24 09:30:35.459841251 -0300
+++ b/lib/portage/const.py	2022-01-24 09:31:51.575857659 -0300
@@ -89,6 +89,8 @@
 
 INCREMENTALS = (
     "ACCEPT_KEYWORDS",
+    "TRACK_KEYWORDS",
+    "DENY_KEYWORDS",
     "CONFIG_PROTECT",
     "CONFIG_PROTECT_MASK",
     "ENV_UNSET",
--- a/lib/portage/package/ebuild/_config/KeywordsManager.py	2022-01-24 09:39:45.539980442 -0300
+++ b/lib/portage/package/ebuild/_config/KeywordsManager.py	2022-01-24 12:39:33.699966471 -0300
@@ -1,4 +1,5 @@
 # Copyright 2010-2021 Gentoo Authors
+# Copyright 2019-2021 Daniel Robbins
 # Distributed under the terms of the GNU General Public License v2
 
 __all__ = ("KeywordsManager",)
@@ -15,13 +16,85 @@
 from portage.versions import _pkg_str
 
 
+class KeywordsResult:
+
+    """
+    This is a new simple class to collect both the accepted keywords calculated, as well as any
+    explicitly disabled keywords, which is also useful information to know (and TRACK_KEYWORDS
+    makes specific use of this.)
+
+    By "explicitly disabled keywords", we mean any KEYWORDS in the ebuild that appear as "-foo".
+    TRACK_KEYWORDS gives this special meaning and is stronger than simply not specifying "foo"
+    in KEYWORDS.
+    """
+
+    def __init__(self, accepted_keywords, disabled_keywords):
+        self.accepted_keywords = accepted_keywords
+        self.disabled_keywords = disabled_keywords
+
+
+def expand_incremental(lists):
+    """
+    This function is very similar to portage.dbapi.porttree's stack_lists() function, except that we
+    keep track of list elements that are explicitly disabled via "-". We return not only the effective
+    list, but also the list of any explicitly disabled list elements that are still having "impact"
+    on the final list. This is used by the TRACK_KEYWORDS feature, so we can know if a particular
+    arch has been *explicitly* disabled for a particular ebuild or not.
+
+    @param lists:
+    @return: two sets, the first of the effective values, the second of any explicitly disabled values.
+    """
+
+    # effective_set contains the evaluated result set of the lists. No '-' prefix tokens will be in this list.
+
+    # disabled_set contains the set of 'disabled' tokens that are still currently 'impacting' our effective
+    # set. Any '-' prefixes will be stripped. A special value of '*' indicates a '-*' was used and is still
+    # impacting the effective set.
+
+    effective_set = set()
+    disabled_set = set()
+
+    for sub_list in lists:
+        for token in sub_list:
+            if token is None:
+                continue
+            if token == "-*":
+                effective_set.clear()
+                disabled_set.add('*')
+            else:
+                if token[:1] in '~-':
+                    raw_token = token[1:]
+                else:
+                    raw_token = token
+                if token[:1] == '-':
+                    if raw_token in effective_set:
+                        effective_set.remove(raw_token)
+                    # -amd64 also turns off ~amd64:
+                    if '~' + raw_token in effective_set:
+                        effective_set.remove('~' + raw_token)
+                    disabled_set.add(raw_token)
+                else:
+                    effective_set.add(token)
+                    if raw_token in disabled_set:
+                        disabled_set.remove(raw_token)
+                    # adding any token will wipe the special '*' disabled value:
+                    if '*' in disabled_set:
+                        disabled_set.remove('*')
+
+    return effective_set, disabled_set
+
+
 class KeywordsManager:
     """Manager class to handle keywords processing and validation"""
 
     def __init__(
-        self, profiles, abs_user_config, user_config=True, global_accept_keywords=""
+        self, profiles, abs_user_config, user_config=True, global_accept_keywords="",
+        global_track_keywords="", global_deny_keywords=""
     ):
         self._pkeywords_list = []
+        self.global_accept_keywords = set(global_accept_keywords.split())
+        self.global_track_keywords = set(global_track_keywords.split())
+        self.global_deny_keywords = set(global_deny_keywords.split())
         rawpkeywords = [
             grabdict_package(
                 os.path.join(x.location, "package.keywords"),
@@ -113,7 +186,7 @@
                     v = tuple(v)
                 self.pkeywordsdict.setdefault(k.cp, {})[k] = v
 
-    def getKeywords(self, cpv, slot, keywords, repo):
+    def getKeywords(self, cpv, slot, keywords, repo) -> list:
         try:
             cpv.slot
         except AttributeError:
@@ -128,7 +201,8 @@
                 pkg_keywords = ordered_by_atom_specificity(cpdict, pkg)
                 if pkg_keywords:
                     keywords.extend(pkg_keywords)
-        return stack_lists(keywords, incremental=True)
+        return list(expand_incremental(keywords)[0])
+        #return stack_lists(keywords, incremental=True)
 
     def isStable(self, pkg, global_accept_keywords, backuped_accept_keywords):
         mygroups = self.getKeywords(pkg, None, pkg._metadata["KEYWORDS"], None)
@@ -158,7 +232,7 @@
                 kw = "~" + kw
             unstable.append(kw)
 
-        return bool(self._getMissingKeywords(pkg, pgroups, set(unstable)))
+        return bool(self._getMissingKeywords(pkg, KeywordsResult(pgroups, set()), set(unstable)))
 
     def getMissingKeywords(
         self,
@@ -207,7 +281,7 @@
         else:
             pgroups = set(pgroups)
 
-        return self._getMissingKeywords(cpv, pgroups, mygroups)
+        return self._getMissingKeywords(cpv, KeywordsResult(pgroups, set()), mygroups)
 
     def getRawMissingKeywords(self, cpv, slot, keywords, repo, global_accept_keywords):
         """
@@ -233,7 +307,7 @@
         mygroups = self.getKeywords(cpv, slot, keywords, repo)
         pgroups = global_accept_keywords.split()
         pgroups = set(pgroups)
-        return self._getMissingKeywords(cpv, pgroups, mygroups)
+        return self._getMissingKeywords(cpv, KeywordsResult(pgroups, set()), mygroups)
 
     @staticmethod
     def _getEgroups(egroups, mygroups):
@@ -257,19 +331,68 @@
                 inc_pgroups.add(x)
         return inc_pgroups
 
-    @staticmethod
-    def _getMissingKeywords(cpv, pgroups, mygroups):
-        """Determines the missing keywords
-
-        @param pgroups: The pkg keywords accepted
-        @type pgroups: list
-        @param mygroups: The ebuild keywords
-        @type mygroups: list
+    def _getMissingKeywords(self, cpv, accepted_kwresult, ebuild_keywords: list):
+        """
+        Note: cpv is an argument because it can help with debugging. Even though we don't use it.
+        This method takes the effective ACCEPT_KEYWORDS and KEYWORDS settings for a particular package,
+        and then determines if the package should be masked or not. The return value is a list of any
+        'missing' KEYWORDS, in other words, a list of keywords where any one of them added to
+        ACCEPT_KEYWORDS would allow the package to be unmasked. So for example, if the accepted_keywords
+        are [], and the ebuild's keywords are [ 'x86', 'amd64' ], you would get [ 'x86', 'amd64' ]
+        returned.
+
+        If no keywords are missing, or in other words the ebuild should be visible and unmasked since
+        the keywords settings are 'good', then an empty list [] is returned.
+
+        If the ebuild has no keywords specified, so that it will always be masked, then the special
+        value [ "**" ] is returned, indicating "you are missing a ** setting for the package to get
+        it keyword unmasked.
+
+        The TRACK_KEYWORDS global allows one arch to track another arch. This way, say, arm64 can
+        track amd64 and have similar keyword masking. TRACK_KEYWORDS of "amd64 ~amd64" on an unstable
+        arm64 system will mean that we effectively have an ACCEPT_KEYWORDS of "amd64 ~amd64 arm64
+        ~arm64".
+
+        TODO: should we make this so ACCEPT_KEYWORDS is effectively "amd64 ~amd64", in other words
+              *ignore our native arch keywords too?*
+
+        There is one exception to this rule and why we don't simply use ACCEPT_KEYWORDS for this
+        purpose. With TRACK_KEYWORDS, it is still possible to have packages on an arch explicitly
+        keyword masked via -arch, like "-arm64".
+
+        If a package in our native arch is ever *explicitly* keyword masked via -arch via
+        package.keywords in profiles or KEYWORDS in the ebuild, then it is truly masked on our
+        arch as well *even if* it is unmasked on the TRACK_KEYWORDS arches. This means that
+        "-arch" in KEYWORDS is "stronger" than simply not having "arch" in KEYWORDS, at least
+        from the perspective of Funtoo's TRACK_KEYWORDS feature.
+
+        This way we still have the ability to hard-keyword-mask packages that are incompatible
+        with certain arches. But in all other respects, we can have the same ebuilds available as
+        another arch.
+
+        @param cpv: package atom, not used at all, but useful to have for debugging.
+        @param accepted_kwresult: effective ACCEPT_KEYWORDS for this package. Also includes
+                                  explicitly disabled keywords.
+        @param ebuild_keywords: effective KEYWORDS for this package -- all '-' entries are already
+                                stripped.
+        @return: A list containing missing keywords. See above for a more detailed explanation.
         """
         match = False
         hasstable = False
         hastesting = False
-        for gp in mygroups:
+        pgroups = accepted_kwresult.accepted_keywords
+
+        # DENY_KEYWORDS (profile variable) sets KEYWORDS that, if they appear, will
+        # cause the package to be masked unconditionally. So this will short-circuit
+        # the calculations and just list the ebuild as masked by any matching
+        # DENY_KEYWORDS if any appear in the ebuild:
+
+        if len(self.global_deny_keywords):
+            deny_keywords = set(ebuild_keywords) & self.global_deny_keywords
+            if len(deny_keywords):
+                return list(deny_keywords)
+
+        for gp in ebuild_keywords:
             if gp == "*":
                 match = True
                 break
@@ -288,20 +411,20 @@
                 hastesting = True
             elif not gp.startswith("-"):
                 hasstable = True
-        if not match and (
-            (hastesting and "~*" in pgroups)
-            or (hasstable and "*" in pgroups)
-            or "**" in pgroups
-        ):
-            match = True
+
         if match:
             missing = []
+        elif (hastesting and "~*" in pgroups) or (hasstable and "*" in pgroups) or "**" in pgroups:
+            missing = []
+        elif not ebuild_keywords:
+            missing = ['**']
+        # TRACK_KEYWORDS functionality. See docstring.
+        elif '*' not in accepted_kwresult.disabled_keywords and \
+            [x for x in ebuild_keywords if x in self.global_track_keywords] and \
+            not [x for x in accepted_kwresult.disabled_keywords if x in self.global_accept_keywords]:
+            missing = []
         else:
-            if not mygroups:
-                # If KEYWORDS is empty then we still have to return something
-                # in order to distinguish from the case of "none missing".
-                mygroups = ["**"]
-            missing = mygroups
+            missing = ebuild_keywords
         return missing
 
     def getPKeywords(self, cpv, slot, repo, global_accept_keywords):
--- a/lib/portage/package/ebuild/_config/special_env_vars.py	2022-01-24 12:41:39.840100289 -0300
+++ b/lib/portage/package/ebuild/_config/special_env_vars.py	2022-01-24 13:27:24.694508016 -0300
@@ -340,6 +340,7 @@
     "RESUMECOMMAND_RSYNC",
     "RESUMECOMMAND_SFTP",
     "SIGNED_OFF_BY",
+    "TRACK_KEYWORDS",
     "UNINSTALL_IGNORE",
     "USE_EXPAND_HIDDEN",
     "USE_ORDER",
--- a/lib/portage/package/ebuild/config.py	2022-01-24 13:30:13.914646413 -0300
+++ b/lib/portage/package/ebuild/config.py	2022-01-24 13:32:52.718776691 -0300
@@ -1309,6 +1309,12 @@
                 global_accept_keywords=self.configdict["defaults"].get(
                     "ACCEPT_KEYWORDS", ""
                 ),
+                global_track_keywords=self.configdict["defaults"].get(
+                    "TRACK_KEYWORDS", ""
+                ),
+                global_deny_keywords=self.configdict["defaults"].get(
+                    "DENY_KEYWORDS", ""
+                ),
             )
         return self._keywords_manager_obj
 
--- a/man/make.conf.5	2022-01-24 13:36:18.074945705 -0300
+++ b/man/make.conf.5	2022-01-24 13:34:16.474845551 -0300
@@ -1233,6 +1233,53 @@
 Note: For the ssh:// scheme, key\-based authentication might be of interest.
 .RE
 .TP
+\fBDENY_KEYWORDS\fR = \fI[space delimited list of KEYWORDS]\fR
+This is a variable intended to be used in profiles to automatically mask
+packages that contain certain keywords. It was created for Funtoo so we
+can use the "next" keyword to include an ebuild in next-release. This is
+how it is used -- the regular release would include DENY_KEYWORDS="next"
+which would result in any ebuilds explicitly tagged with KEYWORDS="next"
+as being masked for regular release users. Basically, just the presence
+of "next" means "this is for next-release, not YOU, stupid!"
+
+Then, next-release would set TRACK_KEYWORDS="next" (see below for more)
+in the profile settings. "next" in KEYWORDS in an ebuild would then cause
+it to be auto-masked in the regular release, and auto-unmasked (even if
+it was not enabled for that arch explicitly) in next-release. The only
+exception here is if there is an explicit "-myarch" in KEYWORDS. This
+*will* mask it on a specific arch (and this is a TRACK_KEYWORDS feature,
+see below for more info on how it all works together.)
+.TP
+\fBTRACK_KEYWORDS\fR = \fI[space delimited list of KEYWORDS]\fR
+Setting this variable to another arch's KEYWORDS allows the native arch to
+inherit the masking settings of another arch.
+
+So, for example, ARM 64-bit can track amd64 and have similar keyword masking,
+without the need to add "arm64" to KEYWORDS in all ebuilds. This is super-handy
+when the main developers are working on amd64, and you only really need to track
+what ebuilds explicitly don't work on ARM 64-bit. TRACK_KEYWORDS of "amd64 ~amd64"
+on an ARM 64-bit system will mean that any ebuild with "amd64" or "~amd64" will be
+unmasked, since the arch is "tracking amd64".
+
+But what if you need to diverge from "amd64" masking for certain ebuilds that you know
+don't work on ARM 64-bit? Easy. With TRACK_KEYWORDS, it is still possible to have
+packages on an arch explicitly keyword masked via -arch, like "-arm64", to mask
+packages that we know don't work on arm64.
+
+If a package in our native arch is ever *explicitly* keyword masked via -arch via
+package.keywords in profiles or KEYWORDS in the ebuild, then it is truly masked on our
+arch as well *even if* it is unmasked on the TRACK_KEYWORDS arches. So we don't lose
+the functionality to explicitly tag ebuilds as being incompatible with an arch,
+yet can still piggy-back on the keyword settings of another arch and just diverge
+where needed.
+
+This setting can be used by distribution maintainers as an interesting and more
+efficient alternative to having independent arch teams.
+
+.br
+Defaults to unset.
+.TP
+.TP
 \fBUNINSTALL_IGNORE\fR = \fI[space delimited list of fnmatch patterns]\fR
 This variable prevents uninstallation of files that match
 specific \fBfnmatch\fR(3) patterns. In order to ignore file
